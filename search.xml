<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>初识全同态加密</title>
    <url>/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/FHE/%E5%88%9D%E8%AF%86%E5%85%A8%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<p>近年来，隐私保护的话题越来越引起人们的重视，使得同态加密等一系列密码学应用技术得到广泛的普及。因此，我想对全同态加密（Fully Homomorphic Encryption，FHE）稍作介绍一下。</p>
<h3 id="FHE的定义"><a href="#FHE的定义" class="headerlink" title="FHE的定义"></a>FHE的定义</h3><p>FHE通俗来说就是一共有$n$个数$m_1, m_2, \ldots, m_n$，加密后对其进行某个函数运算$f(E(m_1), E(m_2), \ldots, E(m_n))$，解密后获得最终运算结果，在这个过程中不暴露$n$个数本身的数值。</p>
<ul>
<li><p>例如，4名员工在相互不知道薪水的情况下，计算他们的平均工资。这4个工资数值分别为$a$, $b$, $c$, $d$，和一个同态加密算法$E()$和其对应的解密算法$D()$。那么最终的平均值为$D(E(a)+E(b)+E(c)+E(d))&#x2F;4$</p>
</li>
<li><p>另外一个例子，有4个人分别知道且只知道一个数值，电商网站的流量，付费转化率，客单价和每月经营成本$a$, $b$, $c$, $d$。那么最终电商网站的利润就是$D(E(a)*E(b)*E(c)-E(d))$</p>
</li>
</ul>
<p>在公钥加密的早期，Rivest 指出了这种隐私计算的重要性，并称之为“隐私同态”。例如，RSA 加密允许进行乘法同态。</p>
<blockquote>
<p>If $f(m)&#x3D;m^2$ and we have access only to $c &#x3D; E_d(m) &#x3D; m^d \pmod{n}$, we can compute $c^2 \pmod{n}$ which is equal to the encryption of $m^2$<br>$$<br>c^2 &#x3D; (m^d)^2 &#x3D; (m^2)^d &#x3D; E_d(m^2)<br>$$</p>
</blockquote>
<p>一个加密函数同时支持加法和乘法同态称为FHE函数。</p>
<h3 id="FHE的计算"><a href="#FHE的计算" class="headerlink" title="FHE的计算"></a>FHE的计算</h3><p><img data-src="https://cdn.jsdelivr.net/gh/ci-shang/Pic-Cloud@master/pic/FHE_comput1.jpg" alt="FHE_comput1"></p>
<ul>
<li><p>明文$m_i$在相同的密钥下经过加密得到密文$c_i&#x3D;E_k(m_i)$</p>
</li>
<li><p>密文 $c_i$ 是函数 $ f $和 $g$的输入</p>
</li>
<li><p>使用密文进行的算术运算称为同态计算，通常是密文的加法或乘法，或乘以一个标量值</p>
</li>
<li><p>一个使用同态的计算机无法访问明文</p>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/ci-shang/Pic-Cloud@master/pic/FHE_comput2.jpg" alt="FHE_comput2"></p>
<ul>
<li><p>函数$f$和$g$的输出都是密文$c_1^{\prime}&#x3D;f(c_1,c_2,c_3)$和$c_2^{\prime}&#x3D;g(c_1,c_4)$</p>
</li>
<li><p>解密$c_1^{\prime}$和$c_2^{\prime}$，得到<br>$$<br>D_k(f(c_1,c_2,c_3)) &#x3D; f(m_1,m_2,m_3)<br>$$</p>
<p>$$<br>D_k(g(c_1,c_4)) &#x3D; g(m_1,m_4)<br>$$</p>
</li>
<li><p>这就是同态加密的<strong>魔力</strong></p>
</li>
<li><p>然而，事情并不像我描述的那么简单。要更好地理解FHE，需要更仔细地研究具体的FHE方法—它们之间存在很大差异</p>
</li>
<li><p>FHE方法在高效实现上面临巨大的挑战—密文的大小非常大</p>
</li>
<li><p>将FHE提升到与公钥密码系统（PKC）相似的效率水平可能需要多年的集中研究</p>
</li>
<li><p>在这次讨论中，我将重点关注BFV和CKKS算法</p>
</li>
<li><p>BFV: Brakerski-Fan-Vercauteren</p>
</li>
<li><p>CKKS: Cheon-Kim-Kim-Song</p>
</li>
</ul>
<h3 id="客户端和服务器的计算"><a href="#客户端和服务器的计算" class="headerlink" title="客户端和服务器的计算"></a>客户端和服务器的计算</h3><ul>
<li>客户端拥有密钥$k$ 和明文$m_i$</li>
<li>客户端加密其数据$c_i &#x3D; E_k(m_i)$</li>
<li>客户端将密文$c_i$提供给服务器</li>
<li>服务器只能访问密文$c_i$</li>
<li>服务器进行同态加法$c_1 \oplus c_2$和同态乘法$c_3 \otimes c_4$。服务器将计算得到的密文$c_i^{\prime}$返回给客户端</li>
<li>客户端解密密文$D_k(c_i^{\prime}) &#x3D; m_i^{\prime}$，获得同态计算后的明文$m_i^{\prime}$</li>
</ul>
<h3 id="FHE的应用"><a href="#FHE的应用" class="headerlink" title="FHE的应用"></a>FHE的应用</h3><p>FHE的应用非常广泛，被称为“密码学中的瑞士军刀”。</p>
<ul>
<li><p>FHE允许在不泄漏隐私数据的情况下外包存储和计算。用户可以将隐私数据上传到云服务平台进行存储和计算</p>
</li>
<li><p>FHE允许对数据库进行私密查询；客户端可以在不让服务器知道检索到哪个记录的情况下获取数据记录</p>
</li>
<li><p>FHE还允许在不同的安全假设下进行两方计算和零知识协议的变体</p>
</li>
</ul>
<h3 id="FHE的限制"><a href="#FHE的限制" class="headerlink" title="FHE的限制"></a>FHE的限制</h3><p>FHE的使用仍然存在一些限制。</p>
<ul>
<li>为了能够使用FHE进行计算，所有输入数据必须用相同的密钥加密</li>
<li>由于FHE函数计算的输出是加密的，未经解密无法知道其正确的原始值</li>
<li>尽管FHE能够对加密数据进行计算，但它无法检查输入是否经过正确加密，或计算是否按预期进行</li>
</ul>
<h3 id="FHE的历史发展"><a href="#FHE的历史发展" class="headerlink" title="FHE的历史发展"></a>FHE的历史发展</h3><p>FHE的概念实际上早在20世纪70年代末就已经被提出。1978年，密码学领域的几位研究者<strong>Rivest、Adleman和Dertouzos</strong>在他们的论文《On Data Banks and Privacy Homomorphisms》中首次提出了在密文上进行计算，从而间接操作原文的系统设想。后来，这一概念被重新总结并命名为全同态加密。</p>
<p>然而，人们并不能找到一个拥有全同态性质的完美算法，既能满足<strong>全同态所有条件，又能轻易证实其安全性的选项</strong>。</p>
<ul>
<li><strong>第一代FHE系统：</strong>2009年，<strong>Craig Gentry</strong>在其博士论文中首次提出了一个合理且安全的FHE系统！这一系统基于理想格（ideal lattice）的假设。Gentry还提出了<strong>Bootstrapping</strong>的重要概念。Bootstrapping是一种针对密文的特殊处理技巧，通过这种处理可以将噪音接近临界值的密文“<strong>刷新</strong>”成噪音很低的新密文。通过Bootstrapping，<strong>一个有限级数系统的噪音可以永远不超过临界值，从而转变为全同态系统</strong></li>
<li><strong>第二代FHE系统：</strong>2011年，两位研究者Brakerski和Vaikuntanathan提出了一种新的全同态加密体系，这一体系基于<strong>格（lattice）加密</strong>的另一种假设，即<strong>Learning with Errors（LWE）</strong>，代表性的有<strong>BFV方案和BGV方案</strong>。这一类体系主要以有限级数的同态加密系统为主，但可以通过Bootstrapping的方式转变为全同态系统。与Gentry在2009年提出的系统相比，该体系使用了更实际的LWE假设</li>
<li><strong>第三代FHE系统：</strong>2013年，Gentry、Sahai和Waters共同提出了新的<strong>GSW全同态加密系统</strong>。GSW系统与BGV系统相似，具有有限级数全同态性质，基于更为简单的LWE假设，并且通过Bootstrapping可以达到全同态。此后，在原来的三代全同态系统基础之上，出现了各种各样新的设计，致力于<strong>优化和加速</strong>BGV与GSW系统的运行效率，比较著名的方案有<strong>FHEW和TFHE</strong>等</li>
<li><strong>第四代FHE系统：</strong>2017年，Cheon、Kim、Kim和Song推出了<strong>近似同态加密CKKS算法</strong>，其具体构造基于BGV方案，但也可以依赖于其他现有的同态加密方案。不同于以往同态加密算法中所追求的解密结果和明文完全一致，CKKS算法的目标是进行<strong>近似计算</strong>。这并不会偏离需求，因为现实生活中大部分运算面对的是<strong>实数（或复数）</strong>，而实数（或复数）的运算往往只需要保留一部分有效数字即可。此外，相比于其他基于LWE&#x2F;RLWE难题的同态方案，CKKS允许误差并放宽准确性的限制，这简化了细节并大大提升了计算效率。CKKS方案被广泛应用在隐私保护机器学习等场景中</li>
</ul>
<h3 id="FHE的库"><a href="#FHE的库" class="headerlink" title="FHE的库"></a>FHE的库</h3><p>现阶段已经有非常多成熟的全同态加密库，主要包含cuFHE、FHEW、FV-NFLib、HEAAN、HElib、PALISADE、SEAL、TFHE 和 Lattigo。</p>
<table>
<thead>
<tr>
<th align="center">库&#x2F;方案</th>
<th align="center">FHEW</th>
<th align="center">TFHE</th>
<th align="center">BGV</th>
<th align="center">BFV</th>
<th align="center">CKKS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">cuFHE</td>
<td align="center"></td>
<td align="center">✅</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">FHEW</td>
<td align="center">✅</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Pyfhel</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">HEAAN</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">Helib</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">✅</td>
<td align="center"></td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">PALISADE</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">SEAL</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">TFHE</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center"></td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
</tbody></table>
<p>除了开发传统的全同态库之外，还有许多团队在研究如何通过GPU、FPGA、ASIC等异构硬件来更好地加速全同态加密算法的计算。比如，cuFHE就是一个比较有名的基于CUDA的GPU加速全同态加密系统。</p>
]]></content>
      <categories>
        <category>同态加密</category>
      </categories>
      <tags>
        <tag>同态加密</tag>
        <tag>BFV</tag>
        <tag>BGV</tag>
        <tag>CKKS</tag>
        <tag>Pyfhel</tag>
      </tags>
  </entry>
  <entry>
    <title>Pyfhel学习：BFV整数加密</title>
    <url>/Pyfhel/Pyfhel/Pyfhel%E5%AD%A6%E4%B9%A0%EF%BC%9ABFV%E6%95%B4%E6%95%B0%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<p>Pyfhel库中包含的内容十分丰富，可以从Pyfhel&#x2F;examples入手，来体验如何使用Pyfhel。下面具体展示其中的BFV方案使用实例。</p>
<h3 id="BFV实例"><a href="#BFV实例" class="headerlink" title="BFV实例"></a>BFV实例</h3><p>BFV (Brakerski-Fan-Vercauteren) 方案是一种基于环上的学习困难问题的同态加密方案。BFV方案允许对编码后的整数进行加密，然后进行同态加密操作（如加法和乘法），最后能够解密出一个近似的结果。论文：<span class="exturl" data-url="aHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi8xNDQucGRm">BFV<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="声明参数"><a href="#声明参数" class="headerlink" title="声明参数"></a><strong>声明参数</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">HE = Pyfhel()</span><br><span class="line">bfv_params = &#123;</span><br><span class="line">    <span class="string">&#x27;scheme&#x27;</span>: <span class="string">&#x27;BFV&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;n&#x27;</span>: <span class="number">2</span> ** <span class="number">13</span>,</span><br><span class="line">    <span class="string">&#x27;t&#x27;</span>: <span class="number">65537</span>,</span><br><span class="line">    <span class="string">&#x27;t_bits&#x27;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">&#x27;sec&#x27;</span>: <span class="number">128</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>‘n’：环的度数。环度指的是同态加密使用的多项式的最大次数加1，因为多项式的次数是从0开始的。这里的值是$2^{13}$，意味着多项式最大次数为$2^{13} - 1$。可以看成是明文数组的长度（明文槽的数量），这些数组中的元素会被编码为一个单一的密文</p>
<p><strong>注意：</strong>环度越大，表示能处理的数据量也越大，但计算复杂度也会增加</p>
</li>
<li><p>‘t’：明文模数。通常用于将明文编码为多项式以及从多项式解码。必须是一个素数满足$t - 1$能被$2^n$整除</p>
</li>
<li><p>‘t_bits’：$t$的比特数。用于生成合适的$t$。如果指定该值就会覆盖上述的$t$值</p>
</li>
<li><p>‘sec’：安全参数。AES密钥的等效长度（以比特位为单位）。用于设置密文模数$q$，可在{128，192，256}中选择。越大意味着越安全，但更低的计算效率</p>
</li>
</ul>
<h4 id="构造密钥"><a href="#构造密钥" class="headerlink" title="构造密钥"></a><strong>构造密钥</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成BFV方案的context</span></span><br><span class="line">HE.contextGen(**bfv_params)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成公/私钥对</span></span><br><span class="line">HE.keyGen()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成选择密钥 --&gt; 允许旋转/移动</span></span><br><span class="line">HE.rotateKeyGen()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成重线性化密钥</span></span><br><span class="line">HE.relinKeyGen()</span><br></pre></td></tr></table></figure>

<h4 id="生成测试数据"><a href="#生成测试数据" class="headerlink" title="生成测试数据"></a><strong>生成测试数据</strong></h4><ul>
<li>定义两个1D的整型数组，编码并加密</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成整型数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># arr1 = [0, 1, ... n-1] (length n)</span></span><br><span class="line"><span class="comment"># 最大可能值为t/2-1</span></span><br><span class="line">arr1 = np.arange(bfv_params[<span class="string">&#x27;n&#x27;</span>], dtype=np.int64)</span><br><span class="line"></span><br><span class="line"><span class="comment"># arr2 = [-t//2, -1, 1] (length 3) --&gt; 编码时将数组剩余部分填充0</span></span><br><span class="line"><span class="comment"># 最小可能值为-t/2</span></span><br><span class="line">arr2 = np.array([-bfv_params[<span class="string">&#x27;t&#x27;</span>] // <span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span>], dtype=np.int64)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将arr1编码为PyPtxt的明文</span></span><br><span class="line">ptxt1 = HE.encodeInt(arr1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># arr2的长度为3，将arr2用0填充为长度n，再编码为PyPtxt的明文</span></span><br><span class="line">ptxt2 = HE.encodeInt(arr2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密明文ptxt1和ptxt2，返回PyCtxt密文</span></span><br><span class="line">ctxt1 = HE.encryptPtxt(ptxt1)</span><br><span class="line">ctxt2 = HE.encryptPtxt(ptxt2)</span><br></pre></td></tr></table></figure>

<h4 id="同态计算"><a href="#同态计算" class="headerlink" title="同态计算"></a><strong>同态计算</strong></h4><p>密文&#x2F;明文必须建立在同一个context下</p>
<ul>
<li><p>密文-密文操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ccSum = ctxt1 + ctxt2</span><br><span class="line">ccSub = ctxt1 - ctxt2</span><br><span class="line">ccMul = ctxt1 * ctxt2</span><br><span class="line">cNeg = -ctxt1</span><br><span class="line">cSq = ctxt1 ** <span class="number">2</span></span><br><span class="line">cPow = ctxt1 ** <span class="number">3</span></span><br><span class="line">cRotR = ctxt1 &gt;&gt; <span class="number">2</span></span><br><span class="line">cRotL = ctxt1 &lt;&lt; <span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>密文-明文操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cpSum = ctxt1 + ptxt2</span><br><span class="line">cpSum1 = ptxt2 + ccMul</span><br><span class="line">cpSub = ctxt1 - ptxt2</span><br><span class="line">cpMul = ctxt1 * ptxt2</span><br></pre></td></tr></table></figure>
</li>
<li><p>乘法重线性化：密文-密文之间的乘法会导致生成的密文多项式的次数增加。为了防止这种增长，通过使用重现性化技术（通常在每次c-c mult之后），从而降低密文多项式的次数到最小规模（两个多项式c0 &amp; c1）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Relinearization-&gt; Right after each multiplication.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;ccMul before relinearization (size <span class="subst">&#123;ccMul.size()&#125;</span>): <span class="subst">&#123;ccMul&#125;</span>&quot;</span>)</span><br><span class="line">~ccMul</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;ccMul after relinearization (size <span class="subst">&#123;ccMul.size()&#125;</span>): <span class="subst">&#123;ccMul&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;cPow after 2 mult&amp;relin rounds:  (size <span class="subst">&#123;cPow.size()&#125;</span>): <span class="subst">&#123;cPow&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="解码并解密"><a href="#解码并解密" class="headerlink" title="解码并解密"></a><strong>解码并解密</strong></h4><ul>
<li>将密文信息进行解码&amp;解密，并进行显示输出</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r1     = HE.decryptInt(ctxt1)</span><br><span class="line">r2     = HE.decryptInt(ctxt2)</span><br><span class="line">rccSum = HE.decryptInt(ccSum)</span><br><span class="line">rccSub = HE.decryptInt(ccSub)</span><br><span class="line">rccMul = HE.decryptInt(ccMul)</span><br><span class="line">rcSq   = HE.decryptInt(cSq  )</span><br><span class="line">rcNeg  = HE.decryptInt(cNeg )</span><br><span class="line">rcPow  = HE.decryptInt(cPow )</span><br><span class="line">rcRotR = HE.decryptInt(cRotR)</span><br><span class="line">rcRotL = HE.decryptInt(cRotL)</span><br><span class="line">rcpSum = HE.decryptInt(cpSum)</span><br><span class="line">rcpSub = HE.decryptInt(cpSub)</span><br><span class="line">rcpMul = HE.decryptInt(cpMul)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Decrypting results&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; Original ciphertexts: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt1 --(decr)--&gt; &quot;</span>, r1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt2 --(decr)--&gt; &quot;</span>, r2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; Ciphertext-ciphertext Ops: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt1 + ctxt2 = ccSum --(decr)--&gt; &quot;</span>, rccSum)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt1 - ctxt2 = ccSub --(decr)--&gt; &quot;</span>, rccSub)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt1 * ctxt2 = ccMul --(decr)--&gt; &quot;</span>, rccMul)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; Single ciphertext: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt1**2      = cSq   --(decr)--&gt; &quot;</span>, rcSq  )</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\t- ctxt1       = cNeg  --(decr)--&gt; &quot;</span>, rcNeg )</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt1**3      = cPow  --(decr)--&gt; &quot;</span>, rcPow )</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt1 &gt;&gt; 2    = cRotR --(decr)--&gt; &quot;</span>, rcRotR)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt1 &lt;&lt; 2    = cRotL --(decr)--&gt; &quot;</span>, rcRotL)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; Ciphertext-plaintext ops: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt1 + ptxt2 = cpSum --(decr)--&gt; &quot;</span>, rcpSum)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt1 - ptxt2 = cpSub --(decr)--&gt; &quot;</span>, rcpSub)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt1 * ptxt2 = cpMul --(decr)--&gt; &quot;</span>, rcpMul)</span><br></pre></td></tr></table></figure>

<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>以上实例具体在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2liYXJyb25kL1B5ZmhlbC9ibG9iL21hc3Rlci9leGFtcGxlcy9EZW1vXzJfSW50ZWdlcl9CRlYucHk=">Pyfhel&#x2F;examples<i class="fa fa-external-link-alt"></i></span>中，有需要可以自行查阅源码。</p>
]]></content>
      <categories>
        <category>Pyfhel</category>
      </categories>
      <tags>
        <tag>同态加密</tag>
        <tag>BFV</tag>
        <tag>Pyfhel</tag>
      </tags>
  </entry>
  <entry>
    <title>Pyfhel学习：CKKS浮点数加密</title>
    <url>/Pyfhel/Pyfhel/Pyfhel%E5%AD%A6%E4%B9%A0%EF%BC%9ACKKS%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<p>Pyfhel库中包含的内容十分丰富，可以从Pyfhel&#x2F;examples入手，来体验如何使用Pyfhel。下面具体展示其中的CKKS方案使用实例。</p>
<h3 id="CKKS实例"><a href="#CKKS实例" class="headerlink" title="CKKS实例"></a>CKKS实例</h3><p>CKKS（Cheon-Kim-Kim-Song）加密方案在同态加密领域应用广泛，尤其在处理实数和复数计算方面表现优越。CKKS方案能够对编码后的近似实数或复数进行加密，并支持同态加密操作（如加法和乘法），最终解密出近似结果。该方案特别适用于需要处理大量实数数据的机器学习和数据分析场景。论文：<span class="exturl" data-url="aHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNi80MjEucGRm">CKKS<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="声明参数"><a href="#声明参数" class="headerlink" title="声明参数"></a><strong>声明参数</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">HE = Pyfhel()</span><br><span class="line">ckks_params = &#123;</span><br><span class="line">    <span class="string">&#x27;scheme&#x27;</span>: <span class="string">&#x27;CKKS&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;n&#x27;</span>: <span class="number">2</span>**<span class="number">14</span>,</span><br><span class="line">    <span class="string">&#x27;scale&#x27;</span>: <span class="number">2</span>**<span class="number">30</span>,</span><br><span class="line">    <span class="string">&#x27;qi_sizes&#x27;</span>: [<span class="number">60</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">60</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>‘n’：环的度数。环度指的是同态加密使用的多项式的最大次数加1，因为多项式的次数是从0开始的。这里的值是$2^{14}$，意味着多项式最大次数为$2^{14} - 1$。可以看成是明文数组的长度（明文槽的数量）。<strong>对于CKKS，$n&#x2F;2$个元素会被编码为一个单一的密文</strong></p>
<p><strong>注意：</strong>环度越大，表示能处理的数据量也越大，但计算复杂度也会增加</p>
</li>
<li><p>‘ scale’：缩放因子。将浮点数转换为定点数，因为浮点数不能直接进行计算</p>
</li>
<li><p>‘qi_sizes’：链中每个素数的比特数</p>
</li>
</ul>
<h4 id="构造密钥"><a href="#构造密钥" class="headerlink" title="构造密钥"></a><strong>构造密钥</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成CKKS方案的context</span></span><br><span class="line">HE.contextGen(**ckks_params)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成公/私钥对</span></span><br><span class="line">HE.keyGen()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成选择密钥 --&gt; 允许旋转/移动</span></span><br><span class="line">HE.rotateKeyGen()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成重线性化密钥</span></span><br><span class="line">HE.relinKeyGen()</span><br></pre></td></tr></table></figure>

<h4 id="生成测试数据"><a href="#生成测试数据" class="headerlink" title="生成测试数据"></a><strong>生成测试数据</strong></h4><ul>
<li>定义两个1D的浮点型数组，编码并加密</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成浮点型数组</span></span><br><span class="line">arr_x = np.array([<span class="number">0.1</span>, <span class="number">0.2</span>, -<span class="number">0.3</span>], dtype=np.float64)</span><br><span class="line">arr_y = np.array([-<span class="number">1.5</span>, <span class="number">2.3</span>, <span class="number">4.7</span>], dtype=np.float64)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将arr_x和arr_y编码为PyPtxt的明文</span></span><br><span class="line"><span class="comment"># 用0填充为长度n，再编码为PyPtxt的明文</span></span><br><span class="line">ptxt_x = HE.encodeFrac(arr_x)</span><br><span class="line">ptxt_y = HE.encodeFrac(arr_y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密明文ptxt_x和ptxt_y，返回PyCtxt密文</span></span><br><span class="line">ctxt_x = HE.encryptPtxt(ptxt_x)</span><br><span class="line">ctxt_y = HE.encryptPtxt(ptxt_y)</span><br></pre></td></tr></table></figure>

<h4 id="同态计算"><a href="#同态计算" class="headerlink" title="同态计算"></a><strong>同态计算</strong></h4><p>密文&#x2F;明文必须建立在同一个context下</p>
<ul>
<li><p>密文-密文操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ccSum = ctxt_x + ctxt_y</span><br><span class="line">ccSub = ctxt_x - ctxt_y</span><br><span class="line">ccMul = ctxt_x * ctxt_y</span><br><span class="line">cNeg = -ctxt_x</span><br><span class="line">cSq = ctxt_x ** <span class="number">2</span></span><br><span class="line">cRotR = ctxt_x &gt;&gt; <span class="number">2</span></span><br><span class="line">cRotL = ctxt_x &lt;&lt; <span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>密文-明文操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cpSum = ctxt_x + ptxt_y</span><br><span class="line">cpSub = ctxt_x - ptxt_y</span><br><span class="line">cpMul = ctxt_x * ptxt_y</span><br></pre></td></tr></table></figure>
</li>
<li><p>乘法重线性化：密文-密文之间的乘法会导致生成的密文多项式的次数增加。为了防止这种增长，通过使用重现性化技术（通常在每次c-c mult之后），从而降低密文多项式的次数到最小规模（两个多项式c0 &amp; c1）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Relinearization-&gt; Right after each multiplication.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;ccMul before relinearization (size <span class="subst">&#123;ccMul.size()&#125;</span>): <span class="subst">&#123;ccMul&#125;</span>&quot;</span>)</span><br><span class="line">~ccMul</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;ccMul after relinearization (size <span class="subst">&#123;ccMul.size()&#125;</span>): <span class="subst">&#123;ccMul&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>重缩放&amp;模切换</p>
<ul>
<li><p>CKKS 进行更复杂的操作需要跟踪 CKKS 缩放因子</p>
</li>
<li><p>使用两个 CKKS 密文（或一个密文和一个明文）进行操作需要它们具有相同的缩放因子和相同的模数级别</p>
</li>
<li><p>缩放因子：乘法产生一个新的缩放因子，它是两个操作数比例的乘积。要缩小密文，请使用 <code>HE.rescale_to_next(ctxt)</code> 函数，该函数将模数切换到 qi 链中的下一个模数，并将密文除以前一个模数。由于这是唯一的缩小操作，建议使用与<code>HE.qi_sizes</code>中的中间模数大小相同的“scale_bits”</p>
</li>
<li><p>模切换：切换到 qi 链中的下一个模数，但不重新缩放。这是通过 <code>HE.mod_switch_to_next(ctxt) </code>函数实现的</p>
</li>
<li><p>为了方便用户，Pyfhel 提供了 <code>HE.align_mod_n_scale(this, other)</code>，它会自动执行重新缩放和模数切换。PyCtxt 的所有 2 -输入重载运算符 (+、-、*、&#x2F;) 都会自动调用此函数。<br>相应的 HE.add、HE.sub、HE.multiply 则不会</p>
</li>
<li><p>在此示例中，计算均方误差，将两个密文的平均值视为真实分布。逐步检查比例和模级：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  1. Mean</span></span><br><span class="line">c_mean = (ctxt_x + ctxt_y) / <span class="number">2</span></span><br><span class="line"><span class="comment">#  2. MSE</span></span><br><span class="line">c_mse_1 = ~((ctxt_x - c_mean)**<span class="number">2</span>)</span><br><span class="line">c_mse_2 = (~(ctxt_y - c_mean)**<span class="number">2</span>)</span><br><span class="line">c_mse = (c_mse_1 + c_mse_2)/ <span class="number">3</span></span><br><span class="line"><span class="comment">#  3. Cumulative sum</span></span><br><span class="line">c_mse += (c_mse &lt;&lt; <span class="number">1</span>)</span><br><span class="line">c_mse += (c_mse &lt;&lt; <span class="number">2</span>)  <span class="comment"># element 0 contains the result</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n5. Rescaling &amp; Mod Switching.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&gt;\tMean: &quot;</span>, c_mean)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&gt;\tMSE_1: &quot;</span>, c_mse_1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&gt;\tMSE_2: &quot;</span>, c_mse_2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&gt;\tMSE: &quot;</span>, c_mse)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="解码并解密"><a href="#解码并解密" class="headerlink" title="解码并解密"></a><strong>解码并解密</strong></h4><ul>
<li>将密文信息进行解码&amp;解密，并进行显示输出</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r_x    = HE.decryptFrac(ctxt_x)</span><br><span class="line">r_y    = HE.decryptFrac(ctxt_y)</span><br><span class="line">rccSum = HE.decryptFrac(ccSum)</span><br><span class="line">rccSub = HE.decryptFrac(ccSub)</span><br><span class="line">rccMul = HE.decryptFrac(ccMul)</span><br><span class="line">rcSq   = HE.decryptFrac(cSq  )</span><br><span class="line">rcNeg  = HE.decryptFrac(cNeg )</span><br><span class="line">rcRotR = HE.decryptFrac(cRotR)</span><br><span class="line">rcRotL = HE.decryptFrac(cRotL)</span><br><span class="line">rcpSum = HE.decryptFrac(cpSum)</span><br><span class="line">rcpSub = HE.decryptFrac(cpSub)</span><br><span class="line">rcpMul = HE.decryptFrac(cpMul)</span><br><span class="line">rmean  = HE.decryptFrac(c_mean)</span><br><span class="line">rmse   = HE.decryptFrac(c_mse)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果为近似值！如果你增加小数，你会注意到误差</span></span><br><span class="line">_r = <span class="keyword">lambda</span> x: np.<span class="built_in">round</span>(x, decimals=<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;6. Decrypting results&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; Original ciphertexts: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt_x --(decr)--&gt; &quot;</span>, _r(r_x))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt_y --(decr)--&gt; &quot;</span>, _r(r_y))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; Ciphertext-ciphertext Ops: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt_x + ctxt_y = ccSum --(decr)--&gt; &quot;</span>, _r(rccSum))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt_x - ctxt_y = ccSub --(decr)--&gt; &quot;</span>, _r(rccSub))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt_x * ctxt_y = ccMul --(decr)--&gt; &quot;</span>, _r(rccMul))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; Single ciphertext: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt_x**2      = cSq   --(decr)--&gt; &quot;</span>, _r(rcSq  ))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\t- ctxt_x       = cNeg  --(decr)--&gt; &quot;</span>, _r(rcNeg ))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt_x &gt;&gt; 4    = cRotR --(decr)--&gt; &quot;</span>, _r(rcRotR))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt_x &lt;&lt; 4    = cRotL --(decr)--&gt; &quot;</span>, _r(rcRotL))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; Ciphertext-plaintext ops: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt_x + ptxt_y = cpSum --(decr)--&gt; &quot;</span>, _r(rcpSum))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt_x - ptxt_y = cpSub --(decr)--&gt; &quot;</span>, _r(rcpSub))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt_x * ptxt_y = cpMul --(decr)--&gt; &quot;</span>, _r(rcpMul))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; Mean Squared error: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tmean(ctxt_x, ctxt_y) = c_mean --(decr)--&gt; &quot;</span>, _r(rmean))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tmse(ctxt_x, ctxt_y)  = c_mse  --(decr)--&gt; &quot;</span>, _r(rmse))</span><br></pre></td></tr></table></figure>

<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>以上实例具体在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2liYXJyb25kL1B5ZmhlbC9ibG9iL21hc3Rlci9leGFtcGxlcy9EZW1vXzNfRmxvYXRfQ0tLUy5weQ==">Pyfhel&#x2F;examples<i class="fa fa-external-link-alt"></i></span>中，有需要可以自行查阅源码。</p>
]]></content>
      <categories>
        <category>Pyfhel</category>
      </categories>
      <tags>
        <tag>同态加密</tag>
        <tag>CKKS</tag>
        <tag>Pyfhel</tag>
      </tags>
  </entry>
  <entry>
    <title>Pyfhel库的安装</title>
    <url>/Pyfhel/Pyfhel/Pyfhel%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>Pyfhel是一个基于Python的强大的同态加密库，可以实现各种高级的加密算法，包括BFV、BGV和CKKS等。Pyfhel实现了多个同态加密的功能，例如加法、乘法、求幂以及标量积等。该库可应用于简单的同态加密算法演示以及机器学习算法等复杂问题。</p>
<p>下面介绍如何在macOS上安装Pyfhel库，Linux系统类似。</p>
<h3 id="安装gcc"><a href="#安装gcc" class="headerlink" title="安装gcc"></a>安装gcc</h3><ul>
<li><p><strong>注意：</strong>不要使用系统自带的clang，这会导致安装Pyfhel报错</p>
<ul>
<li>macOS：<code>brew install gcc</code></li>
<li>Ubuntu: <code>sudo apt install gcc g++</code></li>
</ul>
</li>
<li><p>查看gcc版本，这里以gcc14版本为例。<code>gcc-14 -v</code></p>
</li>
<li><p>macOS用户还必须设置<strong>多个环境变量</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Brew installs GCC in /opt/homebrew/bin on Apple Silicon and /usr/local/bin on Intel.</span></span><br><span class="line"><span class="keyword">if</span> [[ $(uname -m) = <span class="string">&quot;arm64&quot;</span> ]]; then BREW_GCC_PATH=<span class="string">&quot;/opt/homebrew/bin&quot;</span>; <span class="keyword">else</span> BREW_GCC_PATH=<span class="string">&quot;/usr/local/bin&quot;</span>; fi</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set CC/CXX environment variables to the most recent GNU GCC</span></span><br><span class="line">export CC=<span class="string">&quot;$BREW_GCC_PATH/$(ls $BREW_GCC_PATH | grep ^gcc-14 | sort -V -r | head -n 1)&quot;</span></span><br><span class="line">export CXX=<span class="string">&quot;$BREW_GCC_PATH/$(ls $BREW_GCC_PATH | grep ^g++-14 | sort -V -r | head -n 1)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set MACOSX_DEPLOYMENT_TARGET to avoid version mismatch warnings</span></span><br><span class="line">echo <span class="string">&quot;MACOSX_DEPLOYMENT_TARGET=$(sw_vers -productVersion)&quot;</span> &gt;&gt; $GITHUB_ENV</span><br><span class="line">echo <span class="string">&quot;MACOSX_DEPLOYMENT_TARGET=$&#123;&#123; env.MACOSX_DEPLOYMENT_TARGET &#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h3><ul>
<li><p><strong>注意：</strong>不要使用系统自带的python，因为它可能是使用clang编译的</p>
<p><code>brew install python</code></p>
</li>
</ul>
<h3 id="安装Pyfhel"><a href="#安装Pyfhel" class="headerlink" title="安装Pyfhel"></a>安装Pyfhel</h3><ul>
<li><p><code>pip install Pyfhel</code></p>
</li>
<li><p>安装最新版本</p>
<p><code>git clone --recursive https://github.com/ibarrond/Pyfhel.git pip install .</code></p>
</li>
<li><p>如果安装过程中有类似的报错<code>[Config.h - No such file or directory]</code>，可能系统中缺少<strong>libconfig-dev</strong>包</p>
<p><code>brew install libconfig-dev</code></p>
</li>
</ul>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>Pyfhel是一个很有用的库，更多内容可以自行查阅：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2liYXJyb25kL1B5ZmhlbC90cmVlL21hc3Rlcj90YWI9cmVhZG1lLW92LWZpbGU=">Pyfhel库<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Pyfhel</category>
      </categories>
      <tags>
        <tag>同态加密</tag>
        <tag>Pyfhel</tag>
      </tags>
  </entry>
</search>
