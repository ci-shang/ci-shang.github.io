<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Pyfhel学习：BFV整数加密</title>
    <url>/Pyfhel/Pyfhel%E5%AD%A6%E4%B9%A0%EF%BC%9ABFV%E6%95%B4%E6%95%B0%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<p>Pyfhel库中包含的内容十分丰富，可以从Pyfhel&#x2F;examples入手，来体验如何使用Pyfhel。下面具体展示其中的BFV方案使用实例。</p>
<h3 id="BFV实例"><a href="#BFV实例" class="headerlink" title="BFV实例"></a>BFV实例</h3><p>BFV (Brakerski&#x2F;Fan-Vercauteren) 方案是一种基于环上的学习困难问题的同态加密方案。BFV方案允许对编码后的整数进行加密，然后进行同态加密操作（如加法和乘法），最后能够解密出一个近似的结果。论文：<span class="exturl" data-url="aHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi8xNDQucGRm">BFV<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="声明参数"><a href="#声明参数" class="headerlink" title="声明参数"></a><strong>声明参数</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">HE = Pyfhel()</span><br><span class="line">bfv_params = &#123;</span><br><span class="line">    <span class="string">&#x27;scheme&#x27;</span>: <span class="string">&#x27;BFV&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;n&#x27;</span>: <span class="number">2</span> ** <span class="number">13</span>,</span><br><span class="line">    <span class="string">&#x27;t&#x27;</span>: <span class="number">65537</span>,</span><br><span class="line">    <span class="string">&#x27;t_bits&#x27;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">&#x27;sec&#x27;</span>: <span class="number">128</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>‘n’：环的度数。环度指的是同态加密使用的多项式的最大次数加1，因为多项式的次数是从0开始的。这里的值是$2^{13}$，意味着多项式最大次数为$2^{13} - 1$。可以看成是明文数组的长度（明文槽的数量），这些数组中的元素会被编码为一个单一的密文</p>
<p><strong>注意：</strong>环度越大，表示能处理的数据量也越大，但计算复杂度也会增加</p>
</li>
<li><p>‘t’：明文模数。通常用于将明文编码为多项式以及从多项式解码。必须是一个素数满足$t - 1$能被$2^n$整除</p>
</li>
<li><p>‘t_bits’：$t$的比特数。用于生成合适的$t$。如果指定该值就会覆盖上述的$t$值</p>
</li>
<li><p>‘sec’：安全参数。AES密钥的等效长度（以比特位为单位）。用于设置密文模数$q$，可在{128，192，256}中选择。越大意味着越安全，但更低的计算效率</p>
</li>
</ul>
<h4 id="构造密钥"><a href="#构造密钥" class="headerlink" title="构造密钥"></a><strong>构造密钥</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成BFV方案的context</span></span><br><span class="line">HE.contextGen(**bfv_params)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成公/私钥对</span></span><br><span class="line">HE.keyGen()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成选择密钥 --&gt; 允许旋转/移动</span></span><br><span class="line">HE.rotateKeyGen()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成重线性化密钥</span></span><br><span class="line">HE.relinKeyGen()</span><br></pre></td></tr></table></figure>

<h4 id="生成测试数据"><a href="#生成测试数据" class="headerlink" title="生成测试数据"></a><strong>生成测试数据</strong></h4><ul>
<li>定义两个1D的整型数组，编码并加密</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成整型数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># arr1 = [0, 1, ... n-1] (length n)</span></span><br><span class="line"><span class="comment"># 最大可能值为t/2-1</span></span><br><span class="line">arr1 = np.arange(bfv_params[<span class="string">&#x27;n&#x27;</span>], dtype=np.int64)</span><br><span class="line"></span><br><span class="line"><span class="comment"># arr2 = [-t//2, -1, 1] (length 3) --&gt; 编码时将数组剩余部分填充0</span></span><br><span class="line"><span class="comment"># 最小可能值为-t/2</span></span><br><span class="line">arr2 = np.array([-bfv_params[<span class="string">&#x27;t&#x27;</span>] // <span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span>], dtype=np.int64)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将arr1编码为PyPtxt的明文</span></span><br><span class="line">ptxt1 = HE.encodeInt(arr1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># arr2的长度为3，将arr2用0填充为长度n，再编码为PyPtxt的明文</span></span><br><span class="line">ptxt2 = HE.encodeInt(arr2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密明文ptxt1和ptxt2，返回PyCtxt密文</span></span><br><span class="line">ctxt1 = HE.encryptPtxt(ptxt1)</span><br><span class="line">ctxt2 = HE.encryptPtxt(ptxt2)</span><br></pre></td></tr></table></figure>

<h4 id="同态计算"><a href="#同态计算" class="headerlink" title="同态计算"></a><strong>同态计算</strong></h4><p>密文&#x2F;明文必须建立在同一个context下</p>
<ul>
<li><p>密文-密文操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ccSum = ctxt1 + ctxt2</span><br><span class="line">ccSub = ctxt1 - ctxt2</span><br><span class="line">ccMul = ctxt1 * ctxt2</span><br><span class="line">cNeg = -ctxt1</span><br><span class="line">cSq = ctxt1 ** <span class="number">2</span></span><br><span class="line">cPow = ctxt1 ** <span class="number">3</span></span><br><span class="line">cRotR = ctxt1 &gt;&gt; <span class="number">2</span></span><br><span class="line">cRotL = ctxt1 &lt;&lt; <span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>密文-明文操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cpSum = ctxt1 + ptxt2</span><br><span class="line">cpSum1 = ptxt2 + ccMul</span><br><span class="line">cpSub = ctxt1 - ptxt2</span><br><span class="line">cpMul = ctxt1 * ptxt2</span><br></pre></td></tr></table></figure>
</li>
<li><p>乘法重线性化：密文-密文之间的乘法会导致生成的密文多项式的次数增加。为了防止这种增长，通过使用重现性化技术（通常在每次c-c mult之后），从而降低密文多项式的次数到最小规模（两个多项式c0 &amp; c1）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Relinearization-&gt; Right after each multiplication.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;ccMul before relinearization (size <span class="subst">&#123;ccMul.size()&#125;</span>): <span class="subst">&#123;ccMul&#125;</span>&quot;</span>)</span><br><span class="line">~ccMul</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;ccMul after relinearization (size <span class="subst">&#123;ccMul.size()&#125;</span>): <span class="subst">&#123;ccMul&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;cPow after 2 mult&amp;relin rounds:  (size <span class="subst">&#123;cPow.size()&#125;</span>): <span class="subst">&#123;cPow&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="解码并解密"><a href="#解码并解密" class="headerlink" title="解码并解密"></a><strong>解码并解密</strong></h4><ul>
<li>将密文信息进行解码&amp;解密，并进行显示输出</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r1     = HE.decryptInt(ctxt1)</span><br><span class="line">r2     = HE.decryptInt(ctxt2)</span><br><span class="line">rccSum = HE.decryptInt(ccSum)</span><br><span class="line">rccSub = HE.decryptInt(ccSub)</span><br><span class="line">rccMul = HE.decryptInt(ccMul)</span><br><span class="line">rcSq   = HE.decryptInt(cSq  )</span><br><span class="line">rcNeg  = HE.decryptInt(cNeg )</span><br><span class="line">rcPow  = HE.decryptInt(cPow )</span><br><span class="line">rcRotR = HE.decryptInt(cRotR)</span><br><span class="line">rcRotL = HE.decryptInt(cRotL)</span><br><span class="line">rcpSum = HE.decryptInt(cpSum)</span><br><span class="line">rcpSub = HE.decryptInt(cpSub)</span><br><span class="line">rcpMul = HE.decryptInt(cpMul)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Decrypting results&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; Original ciphertexts: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt1 --(decr)--&gt; &quot;</span>, r1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt2 --(decr)--&gt; &quot;</span>, r2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; Ciphertext-ciphertext Ops: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt1 + ctxt2 = ccSum --(decr)--&gt; &quot;</span>, rccSum)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt1 - ctxt2 = ccSub --(decr)--&gt; &quot;</span>, rccSub)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt1 * ctxt2 = ccMul --(decr)--&gt; &quot;</span>, rccMul)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; Single ciphertext: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt1**2      = cSq   --(decr)--&gt; &quot;</span>, rcSq  )</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\t- ctxt1       = cNeg  --(decr)--&gt; &quot;</span>, rcNeg )</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt1**3      = cPow  --(decr)--&gt; &quot;</span>, rcPow )</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt1 &gt;&gt; 2    = cRotR --(decr)--&gt; &quot;</span>, rcRotR)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt1 &lt;&lt; 2    = cRotL --(decr)--&gt; &quot;</span>, rcRotL)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; Ciphertext-plaintext ops: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt1 + ptxt2 = cpSum --(decr)--&gt; &quot;</span>, rcpSum)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt1 - ptxt2 = cpSub --(decr)--&gt; &quot;</span>, rcpSub)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt1 * ptxt2 = cpMul --(decr)--&gt; &quot;</span>, rcpMul)</span><br></pre></td></tr></table></figure>

<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>以上实例具体在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2liYXJyb25kL1B5ZmhlbC9ibG9iL21hc3Rlci9leGFtcGxlcy9EZW1vXzJfSW50ZWdlcl9CRlYucHk=">Pyfhel&#x2F;examples<i class="fa fa-external-link-alt"></i></span>中，有需要可以自行查阅源码。</p>
]]></content>
      <categories>
        <category>Pyfhel</category>
      </categories>
      <tags>
        <tag>Pyfhel</tag>
        <tag>BFV</tag>
        <tag>同态加密</tag>
      </tags>
  </entry>
  <entry>
    <title>Pyfhel学习：CKKS浮点数加密</title>
    <url>/Pyfhel/Pyfhel%E5%AD%A6%E4%B9%A0%EF%BC%9ACKKS%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<p>Pyfhel库中包含的内容十分丰富，可以从Pyfhel&#x2F;examples入手，来体验如何使用Pyfhel。下面具体展示其中的CKKS方案使用实例。</p>
<h3 id="CKKS实例"><a href="#CKKS实例" class="headerlink" title="CKKS实例"></a>CKKS实例</h3><p>CKKS（Cheon-Kim-Kim-Song）加密方案在同态加密领域应用广泛，尤其在处理实数和复数计算方面表现优越。CKKS方案能够对编码后的近似实数或复数进行加密，并支持同态加密操作（如加法和乘法），最终解密出近似结果。该方案特别适用于需要处理大量实数数据的机器学习和数据分析场景。论文：<span class="exturl" data-url="aHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNi80MjEucGRm">CKKS<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="声明参数"><a href="#声明参数" class="headerlink" title="声明参数"></a><strong>声明参数</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">HE = Pyfhel()</span><br><span class="line">ckks_params = &#123;</span><br><span class="line">    <span class="string">&#x27;scheme&#x27;</span>: <span class="string">&#x27;CKKS&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;n&#x27;</span>: <span class="number">2</span>**<span class="number">14</span>,</span><br><span class="line">    <span class="string">&#x27;scale&#x27;</span>: <span class="number">2</span>**<span class="number">30</span>,</span><br><span class="line">    <span class="string">&#x27;qi_sizes&#x27;</span>: [<span class="number">60</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">60</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>‘n’：环的度数。环度指的是同态加密使用的多项式的最大次数加1，因为多项式的次数是从0开始的。这里的值是$2^{14}$，意味着多项式最大次数为$2^{14} - 1$。可以看成是明文数组的长度（明文槽的数量）。<strong>对于CKKS，$n&#x2F;2$个元素会被编码为一个单一的密文</strong></p>
<p><strong>注意：</strong>环度越大，表示能处理的数据量也越大，但计算复杂度也会增加</p>
</li>
<li><p>‘ scale’：缩放因子。将浮点数转换为定点数，因为浮点数不能直接进行计算</p>
</li>
<li><p>‘qi_sizes’：链中每个素数的比特数</p>
</li>
</ul>
<h4 id="构造密钥"><a href="#构造密钥" class="headerlink" title="构造密钥"></a><strong>构造密钥</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成CKKS方案的context</span></span><br><span class="line">HE.contextGen(**ckks_params)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成公/私钥对</span></span><br><span class="line">HE.keyGen()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成选择密钥 --&gt; 允许旋转/移动</span></span><br><span class="line">HE.rotateKeyGen()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成重线性化密钥</span></span><br><span class="line">HE.relinKeyGen()</span><br></pre></td></tr></table></figure>

<h4 id="生成测试数据"><a href="#生成测试数据" class="headerlink" title="生成测试数据"></a><strong>生成测试数据</strong></h4><ul>
<li>定义两个1D的浮点型数组，编码并加密</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成浮点型数组</span></span><br><span class="line">arr_x = np.array([<span class="number">0.1</span>, <span class="number">0.2</span>, -<span class="number">0.3</span>], dtype=np.float64)</span><br><span class="line">arr_y = np.array([-<span class="number">1.5</span>, <span class="number">2.3</span>, <span class="number">4.7</span>], dtype=np.float64)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将arr_x和arr_y编码为PyPtxt的明文</span></span><br><span class="line"><span class="comment"># 用0填充为长度n，再编码为PyPtxt的明文</span></span><br><span class="line">ptxt_x = HE.encodeFrac(arr_x)</span><br><span class="line">ptxt_y = HE.encodeFrac(arr_y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密明文ptxt_x和ptxt_y，返回PyCtxt密文</span></span><br><span class="line">ctxt_x = HE.encryptPtxt(ptxt_x)</span><br><span class="line">ctxt_y = HE.encryptPtxt(ptxt_y)</span><br></pre></td></tr></table></figure>

<h4 id="同态计算"><a href="#同态计算" class="headerlink" title="同态计算"></a><strong>同态计算</strong></h4><p>密文&#x2F;明文必须建立在同一个context下</p>
<ul>
<li><p>密文-密文操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ccSum = ctxt_x + ctxt_y</span><br><span class="line">ccSub = ctxt_x - ctxt_y</span><br><span class="line">ccMul = ctxt_x * ctxt_y</span><br><span class="line">cNeg = -ctxt_x</span><br><span class="line">cSq = ctxt_x ** <span class="number">2</span></span><br><span class="line">cRotR = ctxt_x &gt;&gt; <span class="number">2</span></span><br><span class="line">cRotL = ctxt_x &lt;&lt; <span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>密文-明文操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cpSum = ctxt_x + ptxt_y</span><br><span class="line">cpSub = ctxt_x - ptxt_y</span><br><span class="line">cpMul = ctxt_x * ptxt_y</span><br></pre></td></tr></table></figure>
</li>
<li><p>乘法重线性化：密文-密文之间的乘法会导致生成的密文多项式的次数增加。为了防止这种增长，通过使用重现性化技术（通常在每次c-c mult之后），从而降低密文多项式的次数到最小规模（两个多项式c0 &amp; c1）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Relinearization-&gt; Right after each multiplication.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;ccMul before relinearization (size <span class="subst">&#123;ccMul.size()&#125;</span>): <span class="subst">&#123;ccMul&#125;</span>&quot;</span>)</span><br><span class="line">~ccMul</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;ccMul after relinearization (size <span class="subst">&#123;ccMul.size()&#125;</span>): <span class="subst">&#123;ccMul&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>重缩放&amp;模切换</p>
<ul>
<li><p>CKKS 进行更复杂的操作需要跟踪 CKKS 缩放因子。</p>
</li>
<li><p>使用两个 CKKS 密文（或一个密文和一个明文）进行操作需要它们具有相同的缩放因子和相同的模数级别。</p>
</li>
<li><p>缩放因子：乘法产生一个新的缩放因子，它是两个操作数比例的乘积。要缩小密文，请使用 <code>HE.rescale_to_next(ctxt)</code> 函数，该函数将模数切换到 qi 链中的下一个模数，并将密文除以前一个模数。由于这是唯一的缩小操作，建议使用与<code>HE.qi_sizes</code>中的中间模数大小相同的“scale_bits”。</p>
</li>
<li><p>模切换：切换到 qi 链中的下一个模数，但不重新缩放。这是通过 <code>HE.mod_switch_to_next(ctxt) </code>函数实现的。</p>
</li>
<li><p>为了方便用户，Pyfhel 提供了 <code>HE.align_mod_n_scale(this, other)</code>，它会自动执行重新缩放和模数切换。PyCtxt 的所有 2 -输入重载运算符 (+、-、*、&#x2F;) 都会自动调用此函数。<br>相应的 HE.add、HE.sub、HE.multiply 则不会。</p>
</li>
<li><p>在此示例中，计算均方误差，将两个密文的平均值视为真实分布。逐步检查比例和模级：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  1. Mean</span></span><br><span class="line">c_mean = (ctxt_x + ctxt_y) / <span class="number">2</span></span><br><span class="line"><span class="comment">#  2. MSE</span></span><br><span class="line">c_mse_1 = ~((ctxt_x - c_mean)**<span class="number">2</span>)</span><br><span class="line">c_mse_2 = (~(ctxt_y - c_mean)**<span class="number">2</span>)</span><br><span class="line">c_mse = (c_mse_1 + c_mse_2)/ <span class="number">3</span></span><br><span class="line"><span class="comment">#  3. Cumulative sum</span></span><br><span class="line">c_mse += (c_mse &lt;&lt; <span class="number">1</span>)</span><br><span class="line">c_mse += (c_mse &lt;&lt; <span class="number">2</span>)  <span class="comment"># element 0 contains the result</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n5. Rescaling &amp; Mod Switching.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&gt;\tMean: &quot;</span>, c_mean)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&gt;\tMSE_1: &quot;</span>, c_mse_1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&gt;\tMSE_2: &quot;</span>, c_mse_2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&gt;\tMSE: &quot;</span>, c_mse)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="解码并解密"><a href="#解码并解密" class="headerlink" title="解码并解密"></a><strong>解码并解密</strong></h4><ul>
<li>将密文信息进行解码&amp;解密，并进行显示输出</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r_x    = HE.decryptFrac(ctxt_x)</span><br><span class="line">r_y    = HE.decryptFrac(ctxt_y)</span><br><span class="line">rccSum = HE.decryptFrac(ccSum)</span><br><span class="line">rccSub = HE.decryptFrac(ccSub)</span><br><span class="line">rccMul = HE.decryptFrac(ccMul)</span><br><span class="line">rcSq   = HE.decryptFrac(cSq  )</span><br><span class="line">rcNeg  = HE.decryptFrac(cNeg )</span><br><span class="line">rcRotR = HE.decryptFrac(cRotR)</span><br><span class="line">rcRotL = HE.decryptFrac(cRotL)</span><br><span class="line">rcpSum = HE.decryptFrac(cpSum)</span><br><span class="line">rcpSub = HE.decryptFrac(cpSub)</span><br><span class="line">rcpMul = HE.decryptFrac(cpMul)</span><br><span class="line">rmean  = HE.decryptFrac(c_mean)</span><br><span class="line">rmse   = HE.decryptFrac(c_mse)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果为近似值！如果你增加小数，你会注意到误差</span></span><br><span class="line">_r = <span class="keyword">lambda</span> x: np.<span class="built_in">round</span>(x, decimals=<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;6. Decrypting results&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; Original ciphertexts: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt_x --(decr)--&gt; &quot;</span>, _r(r_x))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt_y --(decr)--&gt; &quot;</span>, _r(r_y))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; Ciphertext-ciphertext Ops: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt_x + ctxt_y = ccSum --(decr)--&gt; &quot;</span>, _r(rccSum))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt_x - ctxt_y = ccSub --(decr)--&gt; &quot;</span>, _r(rccSub))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt_x * ctxt_y = ccMul --(decr)--&gt; &quot;</span>, _r(rccMul))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; Single ciphertext: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt_x**2      = cSq   --(decr)--&gt; &quot;</span>, _r(rcSq  ))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\t- ctxt_x       = cNeg  --(decr)--&gt; &quot;</span>, _r(rcNeg ))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt_x &gt;&gt; 4    = cRotR --(decr)--&gt; &quot;</span>, _r(rcRotR))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt_x &lt;&lt; 4    = cRotL --(decr)--&gt; &quot;</span>, _r(rcRotL))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; Ciphertext-plaintext ops: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt_x + ptxt_y = cpSum --(decr)--&gt; &quot;</span>, _r(rcpSum))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt_x - ptxt_y = cpSub --(decr)--&gt; &quot;</span>, _r(rcpSub))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tctxt_x * ptxt_y = cpMul --(decr)--&gt; &quot;</span>, _r(rcpMul))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; Mean Squared error: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tmean(ctxt_x, ctxt_y) = c_mean --(decr)--&gt; &quot;</span>, _r(rmean))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   -&gt;\tmse(ctxt_x, ctxt_y)  = c_mse  --(decr)--&gt; &quot;</span>, _r(rmse))</span><br></pre></td></tr></table></figure>

<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>以上实例具体在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2liYXJyb25kL1B5ZmhlbC9ibG9iL21hc3Rlci9leGFtcGxlcy9EZW1vXzNfRmxvYXRfQ0tLUy5weQ==">Pyfhel&#x2F;examples<i class="fa fa-external-link-alt"></i></span>中，有需要可以自行查阅源码。</p>
]]></content>
      <categories>
        <category>Pyfhel</category>
      </categories>
      <tags>
        <tag>Pyfhel</tag>
        <tag>同态加密</tag>
        <tag>CKKS</tag>
      </tags>
  </entry>
  <entry>
    <title>Pyfhel库的安装</title>
    <url>/Pyfhel/Pyfhel%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>Pyfhel是一个基于Python的强大的同态加密库，可以实现各种高级的加密算法，包括BFV、BGV和CKKS等。Pyfhel实现了多个同态加密的功能，例如加法、乘法、求幂以及标量积等。该库可应用于简单的同态加密算法演示以及机器学习算法等复杂问题。</p>
<p>下面介绍如何在macOS上安装Pyfhel库，Linux系统类似。</p>
<h3 id="安装gcc"><a href="#安装gcc" class="headerlink" title="安装gcc"></a>安装gcc</h3><ul>
<li><p><strong>注意：</strong>不要使用系统自带的clang，这会导致安装Pyfhel报错</p>
<ul>
<li>macOS：<code>brew install gcc</code></li>
<li>Ubuntu: <code>sudo apt install gcc g++</code></li>
</ul>
</li>
<li><p>查看gcc版本，这里以gcc14版本为例。<code>gcc-14 -v</code></p>
</li>
<li><p>macOS用户还必须设置<strong>多个环境变量</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Brew installs GCC in /opt/homebrew/bin on Apple Silicon and /usr/local/bin on Intel.</span></span><br><span class="line"><span class="keyword">if</span> [[ $(uname -m) = <span class="string">&quot;arm64&quot;</span> ]]; then BREW_GCC_PATH=<span class="string">&quot;/opt/homebrew/bin&quot;</span>; <span class="keyword">else</span> BREW_GCC_PATH=<span class="string">&quot;/usr/local/bin&quot;</span>; fi</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set CC/CXX environment variables to the most recent GNU GCC</span></span><br><span class="line">export CC=<span class="string">&quot;$BREW_GCC_PATH/$(ls $BREW_GCC_PATH | grep ^gcc-14 | sort -V -r | head -n 1)&quot;</span></span><br><span class="line">export CXX=<span class="string">&quot;$BREW_GCC_PATH/$(ls $BREW_GCC_PATH | grep ^g++-14 | sort -V -r | head -n 1)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set MACOSX_DEPLOYMENT_TARGET to avoid version mismatch warnings</span></span><br><span class="line">echo <span class="string">&quot;MACOSX_DEPLOYMENT_TARGET=$(sw_vers -productVersion)&quot;</span> &gt;&gt; $GITHUB_ENV</span><br><span class="line">echo <span class="string">&quot;MACOSX_DEPLOYMENT_TARGET=$&#123;&#123; env.MACOSX_DEPLOYMENT_TARGET &#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h3><ul>
<li><p><strong>注意：</strong>不要使用系统自带的python，因为它可能是使用clang编译的</p>
<p><code>brew install python</code></p>
</li>
</ul>
<h3 id="安装Pyfhel"><a href="#安装Pyfhel" class="headerlink" title="安装Pyfhel"></a>安装Pyfhel</h3><ul>
<li><p><code>pip install Pyfhel</code></p>
</li>
<li><p>安装最新版本</p>
<p><code>git clone --recursive https://github.com/ibarrond/Pyfhel.git pip install .</code></p>
</li>
<li><p>如果安装过程中有类似的报错<code>[Config.h - No such file or directory]</code>，可能系统中缺少<strong>libconfig-dev</strong>包</p>
<p><code>brew install libconfig-dev</code></p>
</li>
</ul>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>Pyfhel是一个很有用的库，更多内容可以自行查阅：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2liYXJyb25kL1B5ZmhlbC90cmVlL21hc3Rlcj90YWI9cmVhZG1lLW92LWZpbGU=">Pyfhel库<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Pyfhel</category>
      </categories>
      <tags>
        <tag>Pyfhel</tag>
        <tag>同态加密</tag>
      </tags>
  </entry>
</search>
